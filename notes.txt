#Node JS with NodeFirm


##Day 1

[PayPal Kraken Forge repo](https://github.com/nodefirm/pkf-5)

Check out [libuv repo](https://github.com/joyent/libuv) and epoll

[Art of Unix programming](https://archive.org/details/ost-computer-science-the_art_of_unix_programming-1) - free ebook

**TODO:** crockford constructors

*tip:* use named functions (helps with debugging)

[pm2](https://github.com/Unitech/pm2) (in austin) vs [upstart](http://upstart.ubuntu.com/) (formerly for ubuntu) vs [initd]() (now for ubuntu) for process watchdogging

*tip:* avoid try/catch (code smell, blocking)

*tip:* pbpaste for getting data into commandline

    $: pbpaste > file.js

###Domains
use domains to handle errors.
you can use domain.intercept to help debug code.
domains are currently unstable however.

###Buffers
Node concept to deal with binary data

originally node used utf8 encoded strings. not performant

buffers can be used to swap encodings

can use buffer code in browser too! (sound analysis, create images)

**TODO:** look at the [html5 tuner](http://www.freetuner.co/) or [leshy labs tuner](http://www.leshylabs.com/apps/tuner/)
http://mohayonao.github.io/timbre.js/PragmaSynth.html

###Streaming
grunt (sync) vs gulpjs (async/piped streams) vs broccoli

stdin /out are streams

Transforms are a type of stream

streams are a popular node primitive

[request](https://github.com/mikeal/request) can help you make http requests

when using streams, you can use `npm install through`
to learn about streaming, you can walk through substacks' [stream adventure](https://github.com/substack/stream-adventure)

stream-adventure uses the same stuff as nodeready

###FS

`require('path')` for x-platform support

`use readFile` will load entire file into memory

you should normally use `fs.createReadStream(src).pipe` and `createWriteStream`

*tip:* use path! and streams! avoid sync!

###TCP
tcp is just duplex sockets

###HTTP

request and cheerio are two popular libraries (compared with native http)

cheerio is good for screenscraping (jquery like)

use url module for url tweaking

`http.globalAgent.maxSockets = 100` wil let you tweak the number of sockets. alternatively, you can set `http.globalAgent = false`
THIS MIGHT BE GETTING REVERTED TO BE FALSE BY DEFAULT IN THE NEXT NODE VERSION









##Day 2

[Twelve factor app](http://12factor.net/) is a set of 'commandments' for modern web apps

###Debugging and Logging
* domains
* AsyncListener
* longjohn
* winston

*tip:* start with [winston](https://github.com/flatiron/winston)

node flags: `--debug` or `node debug <script>`

commands:
* `c` continue
* `n` next
* `s` step
* `o` step out
* `pause` halt execution
* `repl` enter interactive

can set breakpoints from the debugger, at lines, scripts, etc
can bind to running process by sending a `kill -SIGUSR1 <pid>`

*tip:* need to be in bash!!

can use `node-debugger` on command line (install npm)
attach to it via `node --debug-brk day2/debugging/02_interval.js`
otherwise use debug code breakpoints. this lets you use a chrome debugger

###Testing
chai for assertions, mocha for async testing

    npm init
    npm i mocha chai --save-dev
    // edit the package.json scripts section to be:
    // "test": "mocha test/*.js -R spec"

if you forget to call the callback function for an async test (param for `it("should foo", function(next){});`), you will see a timeout

you can use `istanbul` to get coverage numbers

    npm install istanbul --save-dev
    // edit the package.json scripts section to be:
    // "test": "istanbul cover _mocha -- test/*.js -R spec"

###Express

    $ node .

is equivalent to

    $ NODE_ENV=development node index.js

can also `$ export NODE_ENV=production` or `$ NODE_ENV=production node index.js`

to pretty print env vars you can :

    console.log('OMG IT RAN:' + JSON.stringify(process.env, null, 2));

####Templating

####Sessions
node community tends to use redis for sessions

####Forking
Fork to spin up a worker using `cluster.fork()`
One process per core needed.
cluster is experimental
can also use `cluster2` which is by ebay and gives more control

####Async
`async.waterfall` can be used for serial exec and `async.each` for parallel

async collection iterators perform parallel ops on arrays (map, filter, each, reduce, detect, etc)

* use *callbacks* for places where they should be called once
* *eventemitters* should be for state transfer
* *streams* are good for state or data transfer, specifically for transforms

async is written in a functional programming style, and is good to read. "beautifully written"

for token generation for example 04:

    $ curl https://github.paypal.com/api/v3/authorizations --user "jichow" --data '{}'
    $ node 04_github_pp_contributors.js jichow TOKEN DemGen-ConsumerApps1/shoppingnodeweb

###Yeoman

*TODO:* read Jen Moneydollars / Jenn Schiffer for some comedies
https://medium.com/cool-code-pal/1f6430781393
https://medium.com/cool-code-pal/cf72b588b1b

generators are a good way to share best practices etc

theres a generator-generator for this purposes

*tip:* use `hotnode` for filesystem monitoring (similar to nodemon)

*tip:* look at..
* `anydb` as starting point for db connections
* `bcrypt` use it.



***
Done!
